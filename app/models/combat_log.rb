require 'timeout'

class CombatLog < ActiveRecord::Base

  has_attached_file :file

  # These methods are generated by activerecord on invocation, so
  # alias doesn't work here.
  def file_size; self.file_file_size; end;
  def file_name; self.file_file_name; end;

  has_many :entities

  # Private: Crunch the log.  Note: Due to how paperclip handles files
  # (directories named for record ids), this cannot be done on a new
  # record.
  # 
  # Returns nothing
  def crunch
    self.entities = Cruncher.crunch(self.file.path).values
  end
  
  module Cruncher
    class << self
      # Public: Primary processing loop. Reads in the file, building data structures for analysis and display
      #
      # Returns a Hash of entities     
      def crunch filename
        entities = {}
        File.open filename do |log|
          while line = log.gets
            entity_name, result = parse line
            entities[entity_name] ||= Entity.new(name: entity_name)
            entities[entity_name].add_effect_result parse_effect_result(result)
          end
        end
        entities
      end

      # Public: Process an individual line and update entities accordingly
      def parse(line)
        timestamp, entity_with_id, target, ability, result = line.split /\]\s\[/
        entity_name, _ = entity_with_id.split /\s\{/
        [entity_name, result]
      rescue ArgumentError => e # Will trigger on the first split. Be
                                # sure not to cause side effects
                                # before this has a chance to trigger
                                # as it calls #parse again with a
                                # repaired string
        if e.message =~ /invalid byte sequence/i
          properly_encoded_line = line.chars.collect do |i|
            i.valid_encoding? ? i : '?'
          end.join
          parse properly_encoded_line
        else
          raise e
        end
      end

      # Public: Parses the result of the effect, the final chunk of the log entry
      #
      # Returns a Hash of result details
      def parse_effect_result(line)
        result_type, details = line.split /\]/
        effect = /\s\{\d*\}\:\s(.+)\s\{/.match(result_type)[1].downcase.to_sym
        amount, type, _ = /\((.*)\)/.match(details)[1].split /\s+/
        {effect: {effect => {amount: amount.to_i, type: type}}}
      end
    end
  end
end
